{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$();\nimport { useState, useEffect } from 'react';\n\n/**\n * Custom hook to track network status and connection quality\n * @returns {Object} Network status information\n */\nexport const useNetworkStatus = () => {\n  _s();\n  const [isOnline, setIsOnline] = useState(navigator.onLine);\n  const [connectionSpeed, setConnectionSpeed] = useState('unknown');\n  const [isSlowConnection, setIsSlowConnection] = useState(false);\n  useEffect(() => {\n    const handleOnline = () => setIsOnline(true);\n    const handleOffline = () => setIsOnline(false);\n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n\n    // Monitor connection speed if supported\n    if ('connection' in navigator) {\n      const connection = navigator.connection;\n      const updateConnectionInfo = () => {\n        setConnectionSpeed(connection.effectiveType || 'unknown');\n        setIsSlowConnection(connection.effectiveType === 'slow-2g' || connection.effectiveType === '2g');\n      };\n      updateConnectionInfo();\n      connection.addEventListener('change', updateConnectionInfo);\n      return () => {\n        window.removeEventListener('online', handleOnline);\n        window.removeEventListener('offline', handleOffline);\n        connection.removeEventListener('change', updateConnectionInfo);\n      };\n    }\n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, []);\n  return {\n    isOnline,\n    connectionSpeed,\n    isSlowConnection\n  };\n};\n\n/**\n * Custom hook for retrying failed operations\n * @param {Function} operation - The operation to retry\n * @param {number} maxRetries - Maximum number of retries\n * @param {number} delay - Delay between retries\n * @returns {Object} Retry state and methods\n */\n_s(useNetworkStatus, \"u8NBp2YJ2Aj1PpHp8T8LmTQVJ7M=\");\nexport const useRetry = (operation, maxRetries = 3, delay = 1000) => {\n  _s2();\n  const [isRetrying, setIsRetrying] = useState(false);\n  const [retryCount, setRetryCount] = useState(0);\n  const [lastError, setLastError] = useState(null);\n  const retry = async () => {\n    if (retryCount >= maxRetries) {\n      return Promise.reject(new Error('Maximum retry attempts exceeded'));\n    }\n    setIsRetrying(true);\n    setRetryCount(prev => prev + 1);\n    try {\n      await new Promise(resolve => setTimeout(resolve, delay * retryCount));\n      const result = await operation();\n      setIsRetrying(false);\n      setRetryCount(0);\n      setLastError(null);\n      return result;\n    } catch (error) {\n      setLastError(error);\n      setIsRetrying(false);\n      throw error;\n    }\n  };\n  const reset = () => {\n    setRetryCount(0);\n    setLastError(null);\n    setIsRetrying(false);\n  };\n  return {\n    retry,\n    reset,\n    isRetrying,\n    retryCount,\n    canRetry: retryCount < maxRetries,\n    lastError\n  };\n};\n\n/**\n * Custom hook for handling loading states with error recovery\n * @param {Function} asyncOperation - The async operation to manage\n * @returns {Object} Loading state and methods\n */\n_s2(useRetry, \"LgjDpoAAmURb7VvUGfiXLfjAn98=\");\nexport const useAsyncOperation = asyncOperation => {\n  _s3();\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [data, setData] = useState(null);\n  const execute = async (...args) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const result = await asyncOperation(...args);\n      setData(result);\n      return result;\n    } catch (err) {\n      setError(err);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n  const reset = () => {\n    setLoading(false);\n    setError(null);\n    setData(null);\n  };\n  return {\n    execute,\n    reset,\n    loading,\n    error,\n    data\n  };\n};\n_s3(useAsyncOperation, \"/I3+rm3BeIgb1ctBwoYXIzHJAOU=\");","map":{"version":3,"names":["useState","useEffect","useNetworkStatus","_s","isOnline","setIsOnline","navigator","onLine","connectionSpeed","setConnectionSpeed","isSlowConnection","setIsSlowConnection","handleOnline","handleOffline","window","addEventListener","connection","updateConnectionInfo","effectiveType","removeEventListener","useRetry","operation","maxRetries","delay","_s2","isRetrying","setIsRetrying","retryCount","setRetryCount","lastError","setLastError","retry","Promise","reject","Error","prev","resolve","setTimeout","result","error","reset","canRetry","useAsyncOperation","asyncOperation","_s3","loading","setLoading","setError","data","setData","execute","args","err"],"sources":["/Users/surajj/Desktop/JobPortal1/frontend/src/hooks/useNetworkStatus.js"],"sourcesContent":["import { useState, useEffect } from 'react';\n\n/**\n * Custom hook to track network status and connection quality\n * @returns {Object} Network status information\n */\nexport const useNetworkStatus = () => {\n  const [isOnline, setIsOnline] = useState(navigator.onLine);\n  const [connectionSpeed, setConnectionSpeed] = useState('unknown');\n  const [isSlowConnection, setIsSlowConnection] = useState(false);\n\n  useEffect(() => {\n    const handleOnline = () => setIsOnline(true);\n    const handleOffline = () => setIsOnline(false);\n\n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n\n    // Monitor connection speed if supported\n    if ('connection' in navigator) {\n      const connection = navigator.connection;\n      \n      const updateConnectionInfo = () => {\n        setConnectionSpeed(connection.effectiveType || 'unknown');\n        setIsSlowConnection(connection.effectiveType === 'slow-2g' || connection.effectiveType === '2g');\n      };\n\n      updateConnectionInfo();\n      connection.addEventListener('change', updateConnectionInfo);\n\n      return () => {\n        window.removeEventListener('online', handleOnline);\n        window.removeEventListener('offline', handleOffline);\n        connection.removeEventListener('change', updateConnectionInfo);\n      };\n    }\n\n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, []);\n\n  return {\n    isOnline,\n    connectionSpeed,\n    isSlowConnection\n  };\n};\n\n/**\n * Custom hook for retrying failed operations\n * @param {Function} operation - The operation to retry\n * @param {number} maxRetries - Maximum number of retries\n * @param {number} delay - Delay between retries\n * @returns {Object} Retry state and methods\n */\nexport const useRetry = (operation, maxRetries = 3, delay = 1000) => {\n  const [isRetrying, setIsRetrying] = useState(false);\n  const [retryCount, setRetryCount] = useState(0);\n  const [lastError, setLastError] = useState(null);\n\n  const retry = async () => {\n    if (retryCount >= maxRetries) {\n      return Promise.reject(new Error('Maximum retry attempts exceeded'));\n    }\n\n    setIsRetrying(true);\n    setRetryCount(prev => prev + 1);\n\n    try {\n      await new Promise(resolve => setTimeout(resolve, delay * retryCount));\n      const result = await operation();\n      setIsRetrying(false);\n      setRetryCount(0);\n      setLastError(null);\n      return result;\n    } catch (error) {\n      setLastError(error);\n      setIsRetrying(false);\n      throw error;\n    }\n  };\n\n  const reset = () => {\n    setRetryCount(0);\n    setLastError(null);\n    setIsRetrying(false);\n  };\n\n  return {\n    retry,\n    reset,\n    isRetrying,\n    retryCount,\n    canRetry: retryCount < maxRetries,\n    lastError\n  };\n};\n\n/**\n * Custom hook for handling loading states with error recovery\n * @param {Function} asyncOperation - The async operation to manage\n * @returns {Object} Loading state and methods\n */\nexport const useAsyncOperation = (asyncOperation) => {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [data, setData] = useState(null);\n\n  const execute = async (...args) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const result = await asyncOperation(...args);\n      setData(result);\n      return result;\n    } catch (err) {\n      setError(err);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const reset = () => {\n    setLoading(false);\n    setError(null);\n    setData(null);\n  };\n\n  return {\n    execute,\n    reset,\n    loading,\n    error,\n    data\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}