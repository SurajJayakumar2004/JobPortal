{"ast":null,"code":"/**\n * Utility functions for handling API errors consistently.\n */\n\n/**\n * Parse API error response into a user-friendly string message\n * @param {Object} error - Axios error object\n * @param {string} defaultMessage - Default error message if parsing fails\n * @returns {string} - Parsed error message\n */\nexport const parseErrorMessage = (error, defaultMessage = 'An error occurred. Please try again.') => {\n  // Handle network errors\n  if (!error.response) {\n    if (error.code === 'ECONNABORTED') {\n      return 'Request timed out. Please check your connection and try again.';\n    }\n    if (error.code === 'ERR_NETWORK') {\n      return 'Network error. Please check your internet connection.';\n    }\n    if (error.message === 'Network Error') {\n      return 'Unable to connect to server. Please try again later.';\n    }\n    return 'Connection error. Please check your internet connection.';\n  }\n  const errorData = error.response.data;\n\n  // Handle FastAPI validation errors (array of error objects)\n  if (Array.isArray(errorData.detail)) {\n    return errorData.detail.map(err => {\n      if (typeof err === 'object' && err.msg) {\n        return err.msg;\n      }\n      if (typeof err === 'string') {\n        return err;\n      }\n      return 'Validation error';\n    }).join(', ');\n  }\n\n  // Handle single string error messages\n  if (typeof errorData.detail === 'string') {\n    return errorData.detail;\n  }\n  if (typeof errorData.message === 'string') {\n    return errorData.message;\n  }\n  if (typeof errorData === 'string') {\n    return errorData;\n  }\n  return defaultMessage;\n};\n\n/**\n * Handle common HTTP status codes with appropriate messages\n * @param {Object} error - Axios error object\n * @returns {string} - Status-specific error message\n */\nexport const getStatusErrorMessage = error => {\n  var _error$response;\n  // Handle network errors first\n  if (!error.response) {\n    return parseErrorMessage(error);\n  }\n  const status = (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status;\n  switch (status) {\n    case 400:\n      return parseErrorMessage(error, 'Invalid request. Please check your input.');\n    case 401:\n      return 'Authentication failed. Please log in again.';\n    case 403:\n      return 'You do not have permission to perform this action.';\n    case 404:\n      return 'The requested resource was not found.';\n    case 409:\n      return parseErrorMessage(error, 'A conflict occurred. This resource may already exist.');\n    case 422:\n      return parseErrorMessage(error, 'Invalid data provided. Please check your input.');\n    case 429:\n      return 'Too many requests. Please try again later.';\n    case 500:\n      return 'Server error. Please try again later.';\n    case 502:\n      return 'Bad gateway. The server is temporarily unavailable.';\n    case 503:\n      return 'Service unavailable. Please try again later.';\n    case 504:\n      return 'Gateway timeout. The request took too long to process.';\n    default:\n      return parseErrorMessage(error);\n  }\n};\n\n/**\n * Enhanced error logger for debugging and monitoring\n * @param {Object} error - Error object\n * @param {string} context - Context where error occurred\n * @param {Object} additionalData - Additional data to log\n */\nexport const logError = (error, context = 'Unknown', additionalData = {}) => {\n  const errorDetails = {\n    context,\n    timestamp: new Date().toISOString(),\n    message: error.message,\n    stack: error.stack,\n    response: error.response ? {\n      status: error.response.status,\n      statusText: error.response.statusText,\n      data: error.response.data\n    } : null,\n    request: error.config ? {\n      url: error.config.url,\n      method: error.config.method,\n      data: error.config.data\n    } : null,\n    ...additionalData\n  };\n  console.group(`ðŸš¨ Error in ${context}`);\n  console.error('Error details:', errorDetails);\n  console.groupEnd();\n\n  // In production, you might want to send this to an error monitoring service\n  // like Sentry, LogRocket, or your own logging endpoint\n};\n\n/**\n * Retry mechanism for failed requests\n * @param {Function} apiCall - The API call function to retry\n * @param {number} maxRetries - Maximum number of retries\n * @param {number} delay - Delay between retries in milliseconds\n * @returns {Promise} - Promise that resolves with the successful response\n */\nexport const retryApiCall = async (apiCall, maxRetries = 3, delay = 1000) => {\n  let lastError;\n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      return await apiCall();\n    } catch (error) {\n      var _error$response2, _error$response3, _error$response4;\n      lastError = error;\n\n      // Don't retry on client errors (4xx) except 408 (timeout)\n      if (((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) >= 400 && ((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.status) < 500 && ((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.status) !== 408) {\n        throw error;\n      }\n      if (attempt < maxRetries) {\n        console.warn(`API call failed (attempt ${attempt}/${maxRetries}). Retrying in ${delay}ms...`);\n        await new Promise(resolve => setTimeout(resolve, delay));\n        delay *= 2; // Exponential backoff\n      }\n    }\n  }\n  throw lastError;\n};\n\n/**\n * Check if error is recoverable (user can retry)\n * @param {Object} error - Error object\n * @returns {boolean} - Whether the error is recoverable\n */\nexport const isRecoverableError = error => {\n  if (!error.response) {\n    return true; // Network errors are usually recoverable\n  }\n  const status = error.response.status;\n\n  // Server errors and timeouts are recoverable\n  if (status >= 500 || status === 408 || status === 429) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Create a standardized error boundary component helper\n * @param {string} componentName - Name of the component for error tracking\n * @returns {Object} - Error boundary state and methods\n */\nexport const createErrorBoundary = componentName => {\n  return {\n    getDerivedStateFromError: error => ({\n      hasError: true,\n      error: error,\n      errorInfo: {\n        componentName,\n        timestamp: new Date().toISOString()\n      }\n    }),\n    componentDidCatch: (error, errorInfo) => {\n      logError(error, `Error Boundary: ${componentName}`, {\n        errorInfo,\n        componentStack: errorInfo.componentStack\n      });\n    }\n  };\n};","map":{"version":3,"names":["parseErrorMessage","error","defaultMessage","response","code","message","errorData","data","Array","isArray","detail","map","err","msg","join","getStatusErrorMessage","_error$response","status","logError","context","additionalData","errorDetails","timestamp","Date","toISOString","stack","statusText","request","config","url","method","console","group","groupEnd","retryApiCall","apiCall","maxRetries","delay","lastError","attempt","_error$response2","_error$response3","_error$response4","warn","Promise","resolve","setTimeout","isRecoverableError","createErrorBoundary","componentName","getDerivedStateFromError","hasError","errorInfo","componentDidCatch","componentStack"],"sources":["/Users/surajj/Desktop/JobPortal/frontend/src/utils/errorHandler.js"],"sourcesContent":["/**\n * Utility functions for handling API errors consistently.\n */\n\n/**\n * Parse API error response into a user-friendly string message\n * @param {Object} error - Axios error object\n * @param {string} defaultMessage - Default error message if parsing fails\n * @returns {string} - Parsed error message\n */\nexport const parseErrorMessage = (error, defaultMessage = 'An error occurred. Please try again.') => {\n  // Handle network errors\n  if (!error.response) {\n    if (error.code === 'ECONNABORTED') {\n      return 'Request timed out. Please check your connection and try again.';\n    }\n    if (error.code === 'ERR_NETWORK') {\n      return 'Network error. Please check your internet connection.';\n    }\n    if (error.message === 'Network Error') {\n      return 'Unable to connect to server. Please try again later.';\n    }\n    return 'Connection error. Please check your internet connection.';\n  }\n\n  const errorData = error.response.data;\n\n  // Handle FastAPI validation errors (array of error objects)\n  if (Array.isArray(errorData.detail)) {\n    return errorData.detail\n      .map(err => {\n        if (typeof err === 'object' && err.msg) {\n          return err.msg;\n        }\n        if (typeof err === 'string') {\n          return err;\n        }\n        return 'Validation error';\n      })\n      .join(', ');\n  }\n\n  // Handle single string error messages\n  if (typeof errorData.detail === 'string') {\n    return errorData.detail;\n  }\n\n  if (typeof errorData.message === 'string') {\n    return errorData.message;\n  }\n\n  if (typeof errorData === 'string') {\n    return errorData;\n  }\n\n  return defaultMessage;\n};\n\n/**\n * Handle common HTTP status codes with appropriate messages\n * @param {Object} error - Axios error object\n * @returns {string} - Status-specific error message\n */\nexport const getStatusErrorMessage = (error) => {\n  // Handle network errors first\n  if (!error.response) {\n    return parseErrorMessage(error);\n  }\n\n  const status = error.response?.status;\n\n  switch (status) {\n    case 400:\n      return parseErrorMessage(error, 'Invalid request. Please check your input.');\n    case 401:\n      return 'Authentication failed. Please log in again.';\n    case 403:\n      return 'You do not have permission to perform this action.';\n    case 404:\n      return 'The requested resource was not found.';\n    case 409:\n      return parseErrorMessage(error, 'A conflict occurred. This resource may already exist.');\n    case 422:\n      return parseErrorMessage(error, 'Invalid data provided. Please check your input.');\n    case 429:\n      return 'Too many requests. Please try again later.';\n    case 500:\n      return 'Server error. Please try again later.';\n    case 502:\n      return 'Bad gateway. The server is temporarily unavailable.';\n    case 503:\n      return 'Service unavailable. Please try again later.';\n    case 504:\n      return 'Gateway timeout. The request took too long to process.';\n    default:\n      return parseErrorMessage(error);\n  }\n};\n\n/**\n * Enhanced error logger for debugging and monitoring\n * @param {Object} error - Error object\n * @param {string} context - Context where error occurred\n * @param {Object} additionalData - Additional data to log\n */\nexport const logError = (error, context = 'Unknown', additionalData = {}) => {\n  const errorDetails = {\n    context,\n    timestamp: new Date().toISOString(),\n    message: error.message,\n    stack: error.stack,\n    response: error.response ? {\n      status: error.response.status,\n      statusText: error.response.statusText,\n      data: error.response.data\n    } : null,\n    request: error.config ? {\n      url: error.config.url,\n      method: error.config.method,\n      data: error.config.data\n    } : null,\n    ...additionalData\n  };\n\n  console.group(`ðŸš¨ Error in ${context}`);\n  console.error('Error details:', errorDetails);\n  console.groupEnd();\n\n  // In production, you might want to send this to an error monitoring service\n  // like Sentry, LogRocket, or your own logging endpoint\n};\n\n/**\n * Retry mechanism for failed requests\n * @param {Function} apiCall - The API call function to retry\n * @param {number} maxRetries - Maximum number of retries\n * @param {number} delay - Delay between retries in milliseconds\n * @returns {Promise} - Promise that resolves with the successful response\n */\nexport const retryApiCall = async (apiCall, maxRetries = 3, delay = 1000) => {\n  let lastError;\n\n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      return await apiCall();\n    } catch (error) {\n      lastError = error;\n      \n      // Don't retry on client errors (4xx) except 408 (timeout)\n      if (error.response?.status >= 400 && error.response?.status < 500 && error.response?.status !== 408) {\n        throw error;\n      }\n\n      if (attempt < maxRetries) {\n        console.warn(`API call failed (attempt ${attempt}/${maxRetries}). Retrying in ${delay}ms...`);\n        await new Promise(resolve => setTimeout(resolve, delay));\n        delay *= 2; // Exponential backoff\n      }\n    }\n  }\n\n  throw lastError;\n};\n\n/**\n * Check if error is recoverable (user can retry)\n * @param {Object} error - Error object\n * @returns {boolean} - Whether the error is recoverable\n */\nexport const isRecoverableError = (error) => {\n  if (!error.response) {\n    return true; // Network errors are usually recoverable\n  }\n\n  const status = error.response.status;\n  \n  // Server errors and timeouts are recoverable\n  if (status >= 500 || status === 408 || status === 429) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Create a standardized error boundary component helper\n * @param {string} componentName - Name of the component for error tracking\n * @returns {Object} - Error boundary state and methods\n */\nexport const createErrorBoundary = (componentName) => {\n  return {\n    getDerivedStateFromError: (error) => ({\n      hasError: true,\n      error: error,\n      errorInfo: {\n        componentName,\n        timestamp: new Date().toISOString()\n      }\n    }),\n    \n    componentDidCatch: (error, errorInfo) => {\n      logError(error, `Error Boundary: ${componentName}`, {\n        errorInfo,\n        componentStack: errorInfo.componentStack\n      });\n    }\n  };\n};\n"],"mappings":"AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,iBAAiB,GAAGA,CAACC,KAAK,EAAEC,cAAc,GAAG,sCAAsC,KAAK;EACnG;EACA,IAAI,CAACD,KAAK,CAACE,QAAQ,EAAE;IACnB,IAAIF,KAAK,CAACG,IAAI,KAAK,cAAc,EAAE;MACjC,OAAO,gEAAgE;IACzE;IACA,IAAIH,KAAK,CAACG,IAAI,KAAK,aAAa,EAAE;MAChC,OAAO,uDAAuD;IAChE;IACA,IAAIH,KAAK,CAACI,OAAO,KAAK,eAAe,EAAE;MACrC,OAAO,sDAAsD;IAC/D;IACA,OAAO,0DAA0D;EACnE;EAEA,MAAMC,SAAS,GAAGL,KAAK,CAACE,QAAQ,CAACI,IAAI;;EAErC;EACA,IAAIC,KAAK,CAACC,OAAO,CAACH,SAAS,CAACI,MAAM,CAAC,EAAE;IACnC,OAAOJ,SAAS,CAACI,MAAM,CACpBC,GAAG,CAACC,GAAG,IAAI;MACV,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAIA,GAAG,CAACC,GAAG,EAAE;QACtC,OAAOD,GAAG,CAACC,GAAG;MAChB;MACA,IAAI,OAAOD,GAAG,KAAK,QAAQ,EAAE;QAC3B,OAAOA,GAAG;MACZ;MACA,OAAO,kBAAkB;IAC3B,CAAC,CAAC,CACDE,IAAI,CAAC,IAAI,CAAC;EACf;;EAEA;EACA,IAAI,OAAOR,SAAS,CAACI,MAAM,KAAK,QAAQ,EAAE;IACxC,OAAOJ,SAAS,CAACI,MAAM;EACzB;EAEA,IAAI,OAAOJ,SAAS,CAACD,OAAO,KAAK,QAAQ,EAAE;IACzC,OAAOC,SAAS,CAACD,OAAO;EAC1B;EAEA,IAAI,OAAOC,SAAS,KAAK,QAAQ,EAAE;IACjC,OAAOA,SAAS;EAClB;EAEA,OAAOJ,cAAc;AACvB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMa,qBAAqB,GAAId,KAAK,IAAK;EAAA,IAAAe,eAAA;EAC9C;EACA,IAAI,CAACf,KAAK,CAACE,QAAQ,EAAE;IACnB,OAAOH,iBAAiB,CAACC,KAAK,CAAC;EACjC;EAEA,MAAMgB,MAAM,IAAAD,eAAA,GAAGf,KAAK,CAACE,QAAQ,cAAAa,eAAA,uBAAdA,eAAA,CAAgBC,MAAM;EAErC,QAAQA,MAAM;IACZ,KAAK,GAAG;MACN,OAAOjB,iBAAiB,CAACC,KAAK,EAAE,2CAA2C,CAAC;IAC9E,KAAK,GAAG;MACN,OAAO,6CAA6C;IACtD,KAAK,GAAG;MACN,OAAO,oDAAoD;IAC7D,KAAK,GAAG;MACN,OAAO,uCAAuC;IAChD,KAAK,GAAG;MACN,OAAOD,iBAAiB,CAACC,KAAK,EAAE,uDAAuD,CAAC;IAC1F,KAAK,GAAG;MACN,OAAOD,iBAAiB,CAACC,KAAK,EAAE,iDAAiD,CAAC;IACpF,KAAK,GAAG;MACN,OAAO,4CAA4C;IACrD,KAAK,GAAG;MACN,OAAO,uCAAuC;IAChD,KAAK,GAAG;MACN,OAAO,qDAAqD;IAC9D,KAAK,GAAG;MACN,OAAO,8CAA8C;IACvD,KAAK,GAAG;MACN,OAAO,wDAAwD;IACjE;MACE,OAAOD,iBAAiB,CAACC,KAAK,CAAC;EACnC;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMiB,QAAQ,GAAGA,CAACjB,KAAK,EAAEkB,OAAO,GAAG,SAAS,EAAEC,cAAc,GAAG,CAAC,CAAC,KAAK;EAC3E,MAAMC,YAAY,GAAG;IACnBF,OAAO;IACPG,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;IACnCnB,OAAO,EAAEJ,KAAK,CAACI,OAAO;IACtBoB,KAAK,EAAExB,KAAK,CAACwB,KAAK;IAClBtB,QAAQ,EAAEF,KAAK,CAACE,QAAQ,GAAG;MACzBc,MAAM,EAAEhB,KAAK,CAACE,QAAQ,CAACc,MAAM;MAC7BS,UAAU,EAAEzB,KAAK,CAACE,QAAQ,CAACuB,UAAU;MACrCnB,IAAI,EAAEN,KAAK,CAACE,QAAQ,CAACI;IACvB,CAAC,GAAG,IAAI;IACRoB,OAAO,EAAE1B,KAAK,CAAC2B,MAAM,GAAG;MACtBC,GAAG,EAAE5B,KAAK,CAAC2B,MAAM,CAACC,GAAG;MACrBC,MAAM,EAAE7B,KAAK,CAAC2B,MAAM,CAACE,MAAM;MAC3BvB,IAAI,EAAEN,KAAK,CAAC2B,MAAM,CAACrB;IACrB,CAAC,GAAG,IAAI;IACR,GAAGa;EACL,CAAC;EAEDW,OAAO,CAACC,KAAK,CAAC,eAAeb,OAAO,EAAE,CAAC;EACvCY,OAAO,CAAC9B,KAAK,CAAC,gBAAgB,EAAEoB,YAAY,CAAC;EAC7CU,OAAO,CAACE,QAAQ,CAAC,CAAC;;EAElB;EACA;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,YAAY,GAAG,MAAAA,CAAOC,OAAO,EAAEC,UAAU,GAAG,CAAC,EAAEC,KAAK,GAAG,IAAI,KAAK;EAC3E,IAAIC,SAAS;EAEb,KAAK,IAAIC,OAAO,GAAG,CAAC,EAAEA,OAAO,IAAIH,UAAU,EAAEG,OAAO,EAAE,EAAE;IACtD,IAAI;MACF,OAAO,MAAMJ,OAAO,CAAC,CAAC;IACxB,CAAC,CAAC,OAAOlC,KAAK,EAAE;MAAA,IAAAuC,gBAAA,EAAAC,gBAAA,EAAAC,gBAAA;MACdJ,SAAS,GAAGrC,KAAK;;MAEjB;MACA,IAAI,EAAAuC,gBAAA,GAAAvC,KAAK,CAACE,QAAQ,cAAAqC,gBAAA,uBAAdA,gBAAA,CAAgBvB,MAAM,KAAI,GAAG,IAAI,EAAAwB,gBAAA,GAAAxC,KAAK,CAACE,QAAQ,cAAAsC,gBAAA,uBAAdA,gBAAA,CAAgBxB,MAAM,IAAG,GAAG,IAAI,EAAAyB,gBAAA,GAAAzC,KAAK,CAACE,QAAQ,cAAAuC,gBAAA,uBAAdA,gBAAA,CAAgBzB,MAAM,MAAK,GAAG,EAAE;QACnG,MAAMhB,KAAK;MACb;MAEA,IAAIsC,OAAO,GAAGH,UAAU,EAAE;QACxBL,OAAO,CAACY,IAAI,CAAC,4BAA4BJ,OAAO,IAAIH,UAAU,kBAAkBC,KAAK,OAAO,CAAC;QAC7F,MAAM,IAAIO,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAER,KAAK,CAAC,CAAC;QACxDA,KAAK,IAAI,CAAC,CAAC,CAAC;MACd;IACF;EACF;EAEA,MAAMC,SAAS;AACjB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMS,kBAAkB,GAAI9C,KAAK,IAAK;EAC3C,IAAI,CAACA,KAAK,CAACE,QAAQ,EAAE;IACnB,OAAO,IAAI,CAAC,CAAC;EACf;EAEA,MAAMc,MAAM,GAAGhB,KAAK,CAACE,QAAQ,CAACc,MAAM;;EAEpC;EACA,IAAIA,MAAM,IAAI,GAAG,IAAIA,MAAM,KAAK,GAAG,IAAIA,MAAM,KAAK,GAAG,EAAE;IACrD,OAAO,IAAI;EACb;EAEA,OAAO,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAM+B,mBAAmB,GAAIC,aAAa,IAAK;EACpD,OAAO;IACLC,wBAAwB,EAAGjD,KAAK,KAAM;MACpCkD,QAAQ,EAAE,IAAI;MACdlD,KAAK,EAAEA,KAAK;MACZmD,SAAS,EAAE;QACTH,aAAa;QACb3B,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;MACpC;IACF,CAAC,CAAC;IAEF6B,iBAAiB,EAAEA,CAACpD,KAAK,EAAEmD,SAAS,KAAK;MACvClC,QAAQ,CAACjB,KAAK,EAAE,mBAAmBgD,aAAa,EAAE,EAAE;QAClDG,SAAS;QACTE,cAAc,EAAEF,SAAS,CAACE;MAC5B,CAAC,CAAC;IACJ;EACF,CAAC;AACH,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}